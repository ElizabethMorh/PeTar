#!/usr/bin/env python3

import numpy as np
import sys
import os
import petar
import getopt

if __name__ == '__main__':

    filename_prefix='data'
    snap_type='origin'
    mode='type'
    snapshot_format='ascii'
    interrupt_mode='bse'
    external_mode='none'
    write_option='w'

    def usage():
        print("A tool to gether objects from a list of snapshots into one file. Only work when interrupt-mode is bse based code")
        print("   The tool scan snapshots in the list and select all singles or binaries with the provided type,")
        print("   then save the data into a new file.")
        print("   An additional column, time, will be added in the new file, which is obtain from the header of snapshots.")
        print("   If -m bid or -m bidfile are used, one more column, bid, will also be added (in front of time).")
        print("   Before reading the output file (loadtxt) by using Python module petar.Particle or petar.Binary, ")
        print("   make sure to use addNewMember('time', np.array([]).astype(float)) first.")
        print("   For -m bid or -m bidfile, two times of addNewMember are needed:")
        print("        addNewMember('bid', np.array([]).astype(int))")
        print("        addNewMember('time', np.array([]).astype(float))")
        print("   Output file has the name style of [prefix].[object_typename].[origin|single|binary]")
        print("        [prefix] is defined in the option -p;")
        print("        [object_typename] is defined by SSE star type shown below;")
        print("        [origin|single|binary] represent the original snapshots from PeTar, generated single or binary ones from petar.data.process, respectively.")
        print("Usage: petar.get.object.snap [options] (type|id|id_filename|bid|bid_filename|mass_range|custom) [typeb|mass_rangeb] data_filename")
        print("  type(typeb): SSE stellar type (e.g. BH, MS) to select target for saving, when the snapshot are binary, typeb for secondary components are needed.")
        print("     The argument can be a combination of multiple types by [type1]_[type2]...")
        print("     For exmaple, 'BH_MS' indicates to find both BH and MS types.")
        print("     If 'no' is added in front of type name, it indicate to select all types except the given one.")
        print("     For exmaple, 'noBH' indicates to find non-BH objects.")
        print("     The base SSE/MOSSE star type names are shown below (number in [] is the original type index):")
        print("         LMS:  deeply or fully convective low mass MS star [0]")
        print("         MS:   Main Sequence star [1]")
        print("         HG:   Hertzsprung Gap [2]")
        print("         GB:   First Giant Branch [3]")
        print("         CHeB: Core Helium Burning [4]")
        print("         FAGB: First Asymptotic Giant Branch [5]")
        print("         SAGB: Second Asymptotic Giant Branch [6]")
        print("         HeMS: Main Sequence Naked Helium star [7]")
        print("         HeHG: Hertzsprung Gap Naked Helium star [8]")
        print("         HeGB: Giant Branch Naked Helium star [9]")
        print("         HeWD: Helium White Dwarf [10]")
        print("         COWD: Carbon/Oxygen White Dwarf [11]")
        print("         ONWD: Oxygen/Neon White Dwarf [12]")
        print("         NS:   Neutron Star [13]")
        print("         BH:   Black Hole [14]")
        print("         SN:   Massless Supernova [15]")
        print("  id: the selected ID of particles to get, more than one ID can be connected by '_'.")
        print("      For example, '1_2_3' indicates that particles with ID of 1,2 or 3 will be recorded.")
        print("      This is used when the option '-m id' is given.")
        print("  id_filename: the name of a file that contain a list of id. This is used when the option '-m idfile' is given.")
        print("  bid/bid_filename: select particles using binary ID generated by CantorPairing of two component id.")
        print("                    This is used when the option '-m bid' or '-m bidfile' is given.")
        print("  mass_range(mass_rangeb): select particles based on mass range. The range is connected by '_'.")
        print("                    For example, '0.5_1' indicates mass between 0.5 and 1.0.")
        print("                    This is used when the option '-m mass' is given.")
        print("  custom: select particles based on user defined selection function.")
        print("          The filename of a python script (no suffix '.py') is provided. ")
        print("          The script includes the defination of selecting function with the format:")
        print("          # When option of '-f' is origin, single or binary:")
        print("          def petar_data_select_function(header, data):")
        print("              # The arguments:")
        print("              # header: snapshot header")
        print("              # data: origin, single or binary snapshot (no correction of c.m. stored in header)")
        print("              # Return filtered data, the format can be different from the original one.")
        print("              # For example, return only the stellar evolution data with mass>10:")
        print("              return data.star[data.mass>10] ")
        print("          # When '-f all' is used:")
        print("          def petar_data_select_function(header, origin, single, binary):")
        print("              # The arguments are origin, single and binary snapshot data")
        print("              # return selected data")
        print("  data_filename: A list of snapshot data path with the original filenames (no suffixes of '.single|.binary').")
        print("                 Each line indicates one snapshot.")
        print("Options:")
        print("  -h(--help): help")        
        print("  -p(--filename-prefix): prefix of output file name: data")
        print("  -f(--snapshot-type): indicate the snapshot type to read: origin, single, binary, all (origin)")
        print("               Notice that the reading snapshot filenames should be the original snapshot name generated by PeTar.")
        print("               When '-f single' or '-f binary' is used, the corresponding snapshots generated by petar.data.process (with suffixes of .single or .binary are read")
        print("               But the original snapshots are still needed to obtain time from the header")
        print("               When '-f all' is used, all snapshots, origin, single and binary, are read; only used for '-m custom'")
        print("  -m(--mode): the detection modes. Options (default: type):")
        print("                  type: select objects based on BSE-based stellar types;")
        print("                  id: select objects based on id; ")
        print("                  idfile: select objects by reading a file of id list;")
        print("                  mass: select objects based on mass range")
        print("              Additional options when '-f binary' is used: ")
        print("                  bid: select binaries based on binary id (CantorPairing); ")
        print("                  bidfile: select binaries by reading a file of binary id list")
        print("  -i(--interrupt-mode): the interruption mode used in petar, choices: bse, mobse (bse)")
        print("  -t(--external-mode): external mode used in petar, choices: galpy, none (none)")
        print("                       when external mode is not none, and the mode is not custom, the position and velocity correction is done fore single and binary snapshots")
        print("  -s(--snapshot-format): snapshot data format: binary, ascii; only for reading original snapshots (ascii)")
        print("  -B(--full-binary): this indicates that the snapshot contains full binary information (when petar.data.process -B is used to generated the binary snapshot)")
        print("  -a(--append): appending data to existing data files")
    try:
        shortargs = 'p:f:Bt:i:s:m:ah'
        longargs = ['append','snapshot-type','full-binary','filename-prefix=','mode=','external-mode=','interrupt-mode=','snapshot-format=','help']
        opts,remainder= getopt.getopt( sys.argv[1:], shortargs, longargs)

        kwargs=dict()
        for opt,arg in opts:
            if opt in ('-h','--help'):
                usage()
                sys.exit(1)
            elif opt in ('-p','--filename-prefix'):
                filename_prefix = arg
            elif opt in ('-f','--snapshot-type'):
                snap_type = arg
                if (arg not in ['all','single','binary','origin']):
                    raise ValueError("Snapshot type is incorrect, given", arg, ", should be all, single, binary or origin")
            elif opt in ('-m', '--mode'):
                mode = arg
            elif opt in ('-B','--full-binary'):
                kwargs['simple_binary'] = False
            elif opt in ('-a','--append'):
                write_option='a'
            elif opt in ('-i','--interrupt-mode'):
                interrupt_mode = arg
            elif opt in ('-t','--external-mode'):
                external_mode = arg
            elif opt in ('-s','--snapshot-format'):
                snapshot_format = arg
                kwargs['snapshot_format'] = arg
            else:
                assert False, "unhandeld option"

    except getopt.GetoptError:
        print('getopt error!')
        usage()
        sys.exit(1)

    if (mode=='bid') | (mode=='bidfile'):
        if (snap_type!='binary'):
            raise ValueError("Mode is %s but snapshot file type (-f) is not binary (given: %s)" % (mode,snap_type))

    if (mode != 'custom') & (snap_type == 'all'):
        raise ValueError("Snapshot type is all but Mode is not custom")

    sse_type=''
    sse_type2=''
    mass_range=[]
    mass_range2=[]
    filename_out=''
    idlist=''
    custom_script=''
    if (mode=='type'): 
        sse_type = remainder[0]
        filename = remainder[1]
        if (snap_type=='binary'):
            sse_type2 = remainder[1]
            filename = remainder[2]
        filename_out = filename_prefix+'.'+sse_type+'.'+snap_type
        if (snap_type=='binary'):     
            filename_out = filename_prefix+'.'+sse_type+'.'+sse_type2+'.'+snap_type
    elif (mode=='id') | (mode=='bid'):
        idarg = remainder[0]
        idlist=[]
        for subtype in idarg.split('_'):
            idlist.append(int(subtype))
        idlist=np.array(idlist)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+idarg
    elif (mode=='idfile') | (mode=='bidfile'):
        idfile = open(remainder[0],'r')
        idlines=idfile.read().splitlines()
        idlist=[]
        for line in idlines:
            idlist.extend([int(x) for x in line.split()])
        idlist=np.array(idlist)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+remainder[0]
    elif (mode=='mass') :
        mass_range = [float(x) for x in remainder[0].split('_')]
        if (len(mass_range)!=2):
            raise ValueError('Mass range should has a format of "min_max", ',remainder[0],' is given.')
        if (snap_type=='binary'):
            mass_range2 = [float(x) for x in remainder[1].split('_')]
            if (len(mass_range2)!=2):
                raise ValueError('Mass range should has a format of "min_max", ',remainder[1],' is given.')
        filename = remainder[1]
        filename_out = filename_prefix+'.m'+remainder[0]+'.'+snap_type
        if (snap_type=='binary'):     
            filename = remainder[2]
            filename_out = filename_prefix+'.m'+remainder[0]+'.m'+remainder[1]+'.'+snap_type
    elif (mode=='custom'):
        custom_script = remainder[0]
        selfun = __import__(custom_script)
        filename = remainder[1]
        filename_out = filename_prefix+'.'+remainder[0]
    else:
        raise ValueError("Mode is not recognized, given ", mode, ", should be type, id, idfile, mass, bid, bidfile or custom.")


    print('Output file: ',filename_out)

    kwargs['filename_prefix'] = filename_prefix
    kwargs['interrupt_mode'] = interrupt_mode
    kwargs['external_mode'] = external_mode

    for key, item in kwargs.items(): print(key,':',item)

    fl = open(filename,'r')
    file_list = fl.read()
    path_list = file_list.splitlines()

    output_data = petar.Particle(**kwargs)
    p1 = petar.Particle(**kwargs)
    p2 = petar.Particle(**kwargs)
    if (snap_type=='binary'):
        output_data = petar.Binary(p1,p2,**kwargs)
    output_data.addNewMember('time',np.array([]).astype(float))

    def select_type(_data, _type):
        sel = np.zeros(_data.size).astype(bool)
        for subtype in _type.split('_'):
            if (subtype[:2]=='no'):
                type_index = petar.BSE_STAR_TYPE_INDEX[subtype[2:]]
                sel = sel | (_data.star.type!=type_index)
            else:
                type_index = petar.BSE_STAR_TYPE_INDEX[subtype]
                sel = sel | (_data.star.type==type_index)
        return sel


    with open(filename_out, write_option) as f:
        for path in path_list:
            print('process ',path)
            header = petar.PeTarDataHeader(path, **kwargs)
            time = header.time
            sel = np.array([])
            read_flag=False
            if (snap_type=='binary'):
                p1_temp = petar.Particle(**kwargs)
                p2_temp = petar.Particle(**kwargs)
                data_temp=petar.Binary(p1_temp, p2_temp, **kwargs)
                if os.path.getsize(path+'.binary')>0:
                    data_temp.loadtxt(path+'.binary')
                    if (mode=='custom'):
                        data_sel = selfun.petar_data_select_function(header, data_temp)
                    elif (external_mode!='none'): 
                        data_temp.pos += header.pos_offset
                        data_temp.vel += header.vel_offset
                        data_temp.p1.pos += header.pos_offset
                        data_temp.p2.pos += header.pos_offset
                        data_temp.p1.vel += header.vel_offset
                        data_temp.p2.vel += header.vel_offset
                    if (mode=='type'):
                        sel1 = select_type(data_temp.p1, sse_type)
                        sel2 = select_type(data_temp.p2, sse_type2)
                        sel = sel1 & sel2
                     
                        sel1 = select_type(data_temp.p1, sse_type2)
                        sel2 = select_type(data_temp.p2, sse_type)
                        sel = sel | (sel1 & sel2)
                    elif (mode=='id') | (mode=='idfile'):
                        sel1 = np.in1d(data_temp.p1.id, idlist)
                        sel2 = np.in1d(data_temp.p2.id, idlist)
                        sel = sel1 | sel2
                    elif (mode=='bid') | (mode=='bidfile'):
                        data_temp.generateBinaryID()
                        sel = np.in1d(data_temp.bid, idlist)
                    elif (mode=='mass'):
                        sel1 = (data_temp.p1.mass >= mass_range[0]) & (data_temp.p1.mass < mass_range[1])
                        sel2 = (data_temp.p2.mass >= mass_range2[0]) & (data_temp.p2.mass < mass_range2[1])
                        sel = sel1 & sel2
 
                        sel1 = (data_temp.p2.mass >= mass_range[0]) & (data_temp.p2.mass < mass_range[1])
                        sel2 = (data_temp.p1.mass >= mass_range2[0]) & (data_temp.p1.mass < mass_range2[1])
                        sel = sel | (sel1 & sel2)
                    read_flag=True
                
            elif (snap_type=='single') | (snap_type=='origin'):
                data_temp=petar.Particle(**kwargs)
                read_flag=False
                if (snap_type=='origin'):
                    if (snapshot_format=='ascii'): data_temp.loadtxt(path, skiprows=1)
                    else: 
                        if (external_mode!='none'): 
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET_WITH_CM)
                        else:
                            data_temp.fromfile(path, offset=petar.HEADER_OFFSET)
                    read_flag=True
                else:
                    if os.path.getsize(path+'.single')>0:
                        data_temp.loadtxt(path+'.single')
                        read_flag=True
                if (external_mode!='none') & (read_flag): 
                    data_temp.pos += header.pos_offset
                    data_temp.vel += header.vel_offset
                if (read_flag):
                    if (mode=='custom'):
                        data_sel = selfun.petar_data_select_function(header, data_temp)
                    elif (external_mode!='none'): 
                        data_temp.pos += header.pos_offset
                        data_temp.vel += header.vel_offset
                    if (mode=='type'):
                        sel = select_type(data_temp, sse_type)
                    elif (mode=='id') | (mode=='idfile'):
                        sel = np.in1d(data_temp.id, idlist)
                    elif (mode=='mass'):
                        sel = (data_temp.mass >= mass_range[0]) & (data_temp.mass < mass_range[1])

            elif (snap_type=='all') & (mode == 'custom'):
                p1_temp = petar.Particle(**kwargs)
                p2_temp = petar.Particle(**kwargs)
                binary=petar.Binary(p1_temp, p2_temp, **kwargs)
                origin=petar.Particle(**kwargs)
                single=petar.Particle(**kwargs)
                if (snapshot_format=='ascii'): origin.loadtxt(path, skiprows=1)
                else: origin.fromfile(path, offset=petar.HEADER_OFFSET)
                if os.path.getsize(path+'.single')>0:
                    single.loadtxt(path+'.single')
                if os.path.getsize(path+'.binary')>0:
                    binary.loadtxt(path+'.binary')
                data_sel = selfun.petar_data_select_function(header, origin, single, binary)
                read_flag = True

            if(read_flag):
                if (mode != 'custom'):
                    data_sel = data_temp[sel]
                data_sel.addNewMember('time',np.ones(data_sel.size)*time)
                data_sel.savetxt(f)
                f.flush()
    
